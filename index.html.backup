<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Time Management</title>
    <script src="https://alcdn.msauth.net/browser/2.38.1/js/msal-browser.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            height: 100vh;
            background: linear-gradient(135deg, #7d7d7d 0%, #393939 100%);
            display: flex;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: all 0.3s;
        }

        .work-items-section {
            height: 60%;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 90px 20px 20px 20px;
        }

        .work-items-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 28px;
            font-weight: bold;
            z-index: 40;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
        }

        .notes-section {
            height: 40%;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-top: 2px solid rgba(255, 255, 255, 0.3);
            position: relative;
            overflow: auto;
        }

        .notes-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 28px;
            font-weight: bold;
            z-index: 40;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
        }

        .timer-sidebar {
            width: 350px;
            background: rgb(160, 160, 160);
            overflow-y: auto;
            overflow-x: hidden;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.2);
            position: relative;
        }

        .timer-sidebar h3 {
            padding: 20px;
            margin: 0;
            background: #3e3e3e;
            color: rgb(255, 255, 255);
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .timer-sidebar::-webkit-scrollbar {
            width: 10px;
        }

        .timer-sidebar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        .timer-sidebar::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
        }

        .timer-sidebar::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.5);
        }


        .active-timer-card {
            padding: 20px;
            border-bottom: 2px solid #e0e0e0;
            background: white;
        }

        .active-timer-card h4 {
            margin: 0 0 15px 0;
            color: #333;
            font-size: 18px;
        }

        .timer-clock-small {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            margin: 15px 0;
            color: #333;
        }

        .progress-bar-small {
            width: 100%;
            height: 20px;
            background: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
            margin: 15px 0;
        }

        .progress-fill-small {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
        }

        .timer-controls {
            display: flex;
            gap: 8px;
            margin-top: 15px;
        }

        .timer-btn {
            flex: 1;
            padding: 8px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: opacity 0.2s;
        }

        .timer-btn:hover {
            opacity: 0.8;
        }

        .timer-btn.play {
            background: #4CAF50;
            color: white;
        }

        .timer-btn.pause {
            background: #FF9800;
            color: white;
        }

        .timer-btn.cancel {
            background: #f44336;
            color: white;
        }

        .timer-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Version Display */
        .version {
            position: fixed;
            bottom: 10px;
            right: 10px;
            color: rgb(0, 0, 0);
            font-size: 12px;
            z-index: 1000;
        }

        /* Application Title */
        .app-title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 28px;
            font-weight: bold;
            z-index: 100;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            white-space: nowrap;
        }

        /* Floating Buttons */
        .floating-btn {
            position: fixed;
            top: 20px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 28px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 100;
            transition: transform 0.2s;
        }

        .floating-btn:hover {
            transform: scale(1.1);
        }

        .add-btn {
            left: 20px;
            background: #4CAF50;
            color: white;
        }

        .save-load-btn {
            left: 90px;
            background: #2196F3;
            color: white;
            font-size: 14px;
            width: auto;
            padding: 0 20px;
            border-radius: 30px;
        }

        .settings-btn {
            left: 205px;
            background: #9C27B0;
            color: white;
            font-size: 14px;
            width: auto;
            padding: 0 20px;
            border-radius: 30px;
        }

        .add-note-btn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 50;
            transition: transform 0.2s;
            background: #FFD700;
            color: #333;
        }

        .add-note-btn:hover {
            transform: scale(1.1);
        }

        /* Kanban Board Container */
        .cards-container {
            display: grid;
            grid-template-columns: repeat(4, 300px);
            gap: 15px;
            flex: 1;
            min-height: 0;
            overflow-x: auto;
            overflow-y: hidden;
            padding-bottom: 10px;
        }

        .cards-container::-webkit-scrollbar {
            height: 10px;
        }

        .cards-container::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
        }

        .cards-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
        }

        .cards-container::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        .kanban-column {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
            overflow: hidden;
        }

        .kanban-column-header {
            font-weight: bold;
            font-size: 18px;
            color: rgb(39, 39, 39);
            text-align: center;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 10px;
            flex-shrink: 0;
        }

        .kanban-column-header.high {
            background: #FFB3BA;
        }

        .kanban-column-header.medium {
            background: #FFE4A3;
        }

        .kanban-column-header.low {
            background: #B4E7B4;
        }

        .kanban-column-header.none {
            background: #AED6F1;
        }

        .kanban-column-cards {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
        }

        .kanban-column-cards::-webkit-scrollbar {
            width: 8px;
        }

        .kanban-column-cards::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 4px;
        }

        .kanban-column-cards::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 4px;
        }

        .kanban-column-cards::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }

        /* Work Item Card - Horizontal */
        .work-card {
            position: relative;
            border-radius: 8px;
            padding: 12px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: all 0.2s;
            min-height: 60px;
            max-height: 80px;
            border: 2px solid rgba(0, 0, 0, 0.3);
        }

        .work-card.high {
            background: #FFB3BA;
        }

        .work-card.medium {
            background: #FFE4A3;
        }

        .work-card.low {
            background: #B4E7B4;
        }

        .work-card.none {
            background: #AED6F1;
        }

        .work-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .work-card.dragging {
            opacity: 0.5;
        }

        .card-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
            overflow: hidden;
        }

        .card-title {
            font-weight: bold;
            font-size: 16px;
            color: #000;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 100%;
        }

        .card-time {
            font-size: 14px;
            color: #333;
            white-space: nowrap;
        }

        /* Floating Box Overlay */
        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 200;
            justify-content: center;
            align-items: center;
        }

        .overlay.active {
            display: flex;
        }

        .floating-box {
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .floating-box h2 {
            margin-bottom: 20px;
            color: #333;
        }

        .form-group {
            margin-bottom: 15px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }

        .form-group input,
        .form-group select {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 5px;
            font-size: 14px;
        }

        .time-inputs {
            display: flex;
            gap: 10px;
        }

        .time-inputs input {
            width: 50%;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }

        .btn {
            flex: 1;
            padding: 12px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: opacity 0.2s;
        }

        .btn:hover {
            opacity: 0.8;
        }

        .btn-primary {
            background: #4CAF50;
            color: white;
        }

        .btn-secondary {
            background: #9E9E9E;
            color: white;
        }

        .btn-danger {
            background: #f44336;
            color: white;
        }

        .btn-info {
            background: #2196F3;
            color: white;
        }

        /* Timer Display */
        .timer-display {
            text-align: center;
        }

        .timer-display h2 {
            margin-bottom: 20px;
        }

        .timer-clock {
            font-size: 48px;
            font-weight: bold;
            margin: 20px 0;
            color: #333;
        }

        .progress-bar {
            width: 100%;
            height: 30px;
            background: #e0e0e0;
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s;
        }

        /* Save/Load Menu */
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        /* Post-it Notes */
        .sticky-note {
            position: absolute;
            width: 200px;
            min-height: 150px;
            max-height: 300px;
            border-radius: 5px;
            box-shadow: 5px 5px 15px rgba(0, 0, 0, 0.3);
            cursor: move;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            word-wrap: break-word;
            transition: transform 0.1s;
            display: flex;
            flex-direction: column;
            resize: both;
            overflow: auto;
            min-width: 150px;
            max-width: 400px;
        }

        .sticky-note::-webkit-resizer {
            background-image: none;
            background-color: rgba(0, 0, 0, 0.3);
            border-radius: 0 0 5px 0;
        }

        .sticky-note.collapsed {
            min-height: 40px;
            max-height: 40px;
            overflow: hidden;
            resize: none;
        }

        .sticky-note.collapsed .note-header {
            height: 100%;
            display: flex;
            align-items: center;
        }

        .sticky-note.collapsed .note-content {
            display: none;
        }

        .sticky-note:hover {
            transform: scale(1.02);
        }

        .sticky-note.dragging {
            opacity: 0.8;
            z-index: 1000;
        }

        .note-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 5px;
            padding: 5px 5px 5px 10px;
            flex-shrink: 0;
        }

        .note-title-header {
            font-weight: bold;
            font-size: 14px;
            color: #333;
            flex: 1;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .note-btn {
            width: 20px;
            height: 20px;
            border: none;
            background: rgba(0, 0, 0, 0.2);
            color: white;
            border-radius: 50%;
            cursor: pointer;
            font-size: 12px;
            line-height: 1;
            padding: 0;
        }

        .note-btn:hover {
            background: rgba(0, 0, 0, 0.4);
        }

        .note-content {
            padding: 10px 15px;
            padding-right: 20px;
            overflow-y: auto;
            overflow-x: hidden;
            flex: 1;
            white-space: pre-wrap;
        }

        .sticky-note.collapsed .note-content {
            overflow: hidden;
        }

        .note-content::-webkit-scrollbar {
            width: 8px;
        }

        .note-content::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
            border-radius: 4px;
        }

        .note-content::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
        }

        .note-content::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.5);
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            padding: 8px 0;
            z-index: 2000;
            display: none;
        }

        .context-menu.active {
            display: block;
        }

        .context-menu-item {
            padding: 10px 20px;
            cursor: pointer;
            font-size: 14px;
            color: #333;
        }

        .context-menu-item:hover {
            background: #f0f0f0;
        }

        .context-menu-item.delete {
            color: #f44336;
        }

        .color-picker {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 15px 0;
        }

        .color-option {
            width: 50px;
            height: 50px;
            border-radius: 5px;
            cursor: pointer;
            border: 3px solid transparent;
            transition: border 0.2s;
        }

        .color-option:hover {
            border-color: #333;
        }

        .color-option.selected {
            border-color: #000;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        /* Live Timer Indicator */
        .live-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            background: #ff0000;
            border-radius: 50%;
            margin-left: 8px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                opacity: 1;
                transform: scale(1);
            }
            50% {
                opacity: 0.5;
                transform: scale(1.2);
            }
        }
    </style>
</head>
<body>
    <!-- Main Content Area -->
    <div class="main-content">
        <!-- Floating Buttons -->
        <button class="floating-btn add-btn" onclick="showAddItemDialog()">+</button>
        <button class="floating-btn save-load-btn" onclick="showSaveLoadDialog()">Save/Load</button>
        <button class="floating-btn settings-btn" onclick="showSettingsDialog()">Settings</button>

        <!-- Version Display -->
        <div class="version">v2.1</div>

        <!-- Work Items Section -->
        <div class="work-items-section">
            <h2 class="work-items-title">Work Item Time Management</h2>
            <div class="cards-container" id="cardsContainer"></div>
        </div>

        <!-- Notes Section -->
        <div class="notes-section" id="notesSection">
            <h2 class="notes-title">Notes</h2>
            <button class="add-note-btn" onclick="showAddNoteDialog()">+</button>
        </div>
    </div>

    <!-- Timer Sidebar -->
    <div class="timer-sidebar" id="timerSidebar">
        <h3>Active Timers</h3>
        <div id="activeTimersContainer"></div>
    </div>

    <!-- Add Item Overlay -->
    <div class="overlay" id="addItemOverlay">
        <div class="floating-box">
            <h2>Add Work Item</h2>
            <div class="form-group">
                <label for="workItemTitle">Title</label>
                <input type="text" id="workItemTitle" placeholder="Enter work item title">
            </div>
            <div class="form-group">
                <label for="workItemDescription">Description</label>
                <textarea id="workItemDescription" placeholder="Enter work item description..." style="width: 100%; height: 100px; padding: 10px; border: 2px solid #ddd; border-radius: 5px; font-size: 14px; resize: vertical;"></textarea>
            </div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="addWorkItem()">Add</button>
                <button class="btn btn-secondary" onclick="clearAddItemForm()">Clear</button>
            </div>
        </div>
    </div>

    <!-- Work Item Detail Overlay -->
    <div class="overlay" id="workItemDetailOverlay">
        <div class="floating-box" style="max-width: 500px;">
            <h2 id="detailTitle">Work Item Details</h2>
            <div class="form-group">
                <label>Title</label>
                <p id="detailTitleText" style="margin: 5px 0; font-size: 16px; font-weight: bold;"></p>
            </div>
            <div class="form-group">
                <label>Description</label>
                <p id="detailDescription" style="margin: 5px 0; font-size: 14px; color: #555; white-space: pre-wrap;"></p>
            </div>
            <div class="form-group">
                <label>Total Time Logged</label>
                <p id="detailTimeLogged" style="margin: 5px 0; font-size: 16px; font-weight: bold; color: #4CAF50;"></p>
            </div>
            <div class="form-group">
                <label>Last 7 Days</label>
                <div id="detailDailyBreakdown" style="margin: 10px 0; max-height: 250px; overflow-y: auto; border: 1px solid #ddd; border-radius: 5px; padding: 10px; background: #f9f9f9;"></div>
            </div>
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="closeWorkItemDetail()">Close</button>
            </div>
        </div>
    </div>

    <!-- Save/Load Overlay -->
    <div class="overlay" id="saveLoadOverlay">
        <div class="floating-box">
            <h2>Save / Load</h2>
            <div class="menu-buttons">
                <button class="btn btn-primary" onclick="saveToJSON()">Save to JSON</button>
                <button class="btn btn-info" onclick="document.getElementById('importFile').click()">Import JSON</button>
                <div id="oneDriveButtons" style="display: none;">
                    <button class="btn btn-primary" onclick="exportToOneDrive()" style="background: #0078D4;">Export to OneDrive</button>
                    <button class="btn btn-info" onclick="importFromOneDrive()" style="background: #0078D4;">Import from OneDrive</button>
                </div>
                <button class="btn btn-info" onclick="showArchiveView()">View Archive</button>
                <button class="btn btn-danger" onclick="clearWork()">Clear Work</button>
                <button class="btn btn-secondary" onclick="closeSaveLoadDialog()">Cancel</button>
            </div>
            <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importJSON(event)">
        </div>
    </div>

    <!-- Add Note Overlay -->
    <div class="overlay" id="addNoteOverlay">
        <div class="floating-box">
            <h2>Add Note</h2>
            <div class="form-group">
                <label for="noteTitle">Note Title</label>
                <input type="text" id="noteTitle" placeholder="Enter note title" style="width: 100%; padding: 10px; border: 2px solid #ddd; border-radius: 5px; font-family: 'Courier New', monospace;">
            </div>
            <div class="form-group">
                <label for="noteText">Note Text</label>
                <textarea id="noteText" placeholder="Enter your note..." style="width: 100%; height: 100px; padding: 10px; border: 2px solid #ddd; border-radius: 5px; font-family: 'Courier New', monospace; resize: vertical;"></textarea>
            </div>
            <div class="form-group">
                <label>Color</label>
                <div class="color-picker">
                    <div class="color-option selected" style="background: #FFD700;" onclick="selectNoteColor('#FFD700', event)"></div>
                    <div class="color-option" style="background: #FFB6C1;" onclick="selectNoteColor('#FFB6C1', event)"></div>
                    <div class="color-option" style="background: #87CEEB;" onclick="selectNoteColor('#87CEEB', event)"></div>
                    <div class="color-option" style="background: #98FB98;" onclick="selectNoteColor('#98FB98', event)"></div>
                    <div class="color-option" style="background: #FFE4B5;" onclick="selectNoteColor('#FFE4B5', event)"></div>
                    <div class="color-option" style="background: #DDA0DD;" onclick="selectNoteColor('#DDA0DD', event)"></div>
                    <div class="color-option" style="background: #F0E68C;" onclick="selectNoteColor('#F0E68C', event)"></div>
                    <div class="color-option" style="background: #FFDAB9;" onclick="selectNoteColor('#FFDAB9', event)"></div>
                </div>
            </div>
            <div class="btn-group">
                <button class="btn btn-primary" onclick="addNote()">Add</button>
                <button class="btn btn-secondary" onclick="clearAddNoteForm()">Clear</button>
            </div>
        </div>
    </div>

    <!-- Audio for alarm -->
    <audio id="alarmSound" preload="auto">
        <source src="data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGF0fPTgjMGHm7A7+OZURE" loop></source>
    </audio>

    <!-- Context Menu for Notes -->
    <div class="context-menu" id="noteContextMenu">
        <div class="context-menu-item delete" onclick="deleteNoteFromContext()">Delete</div>
    </div>

    <!-- Context Menu for Work Items -->
    <div class="context-menu" id="workItemContextMenu">
        <div class="context-menu-item" onclick="archiveWorkItemFromContext()">Archive</div>
        <div class="context-menu-item delete" onclick="deleteWorkItemFromContext()">Delete</div>
    </div>

    <!-- Clear Confirmation Overlay -->
    <div class="overlay" id="clearConfirmationOverlay">
        <div class="floating-box">
            <h2>Clear All Data</h2>
            <p style="margin: 20px 0; text-align: center; font-size: 16px;">Are you sure you want to wipe all work items and notes? This action cannot be undone.</p>
            <div class="btn-group">
                <button class="btn btn-danger" onclick="confirmClearWork()">Yes, Clear All</button>
                <button class="btn btn-secondary" onclick="closeClearConfirmationDialog()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Archive View Overlay -->
    <div class="overlay" id="archiveViewOverlay">
        <div class="floating-box" style="max-width: 600px; max-height: 80vh;">
            <h2>Archived Items</h2>
            <div id="archiveList" style="max-height: 400px; overflow-y: auto; margin: 20px 0;">
                <!-- Archive items will be rendered here -->
            </div>
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="closeArchiveView()">Close</button>
            </div>
        </div>
    </div>

    <!-- Archive Confirmation Overlay -->
    <div class="overlay" id="archiveConfirmationOverlay">
        <div class="floating-box">
            <h2>Archive Work Item</h2>
            <div style="margin: 20px 0;">
                <p style="font-size: 16px; margin-bottom: 15px; color: #333;">You are about to archive:</p>
                <p style="font-weight: bold; font-size: 18px; color: #000; margin-bottom: 20px;" id="archiveConfirmItemTitle"></p>
                <div style="background: #FFF3CD; border: 2px solid #FFC107; border-radius: 8px; padding: 15px; margin: 20px 0;">
                    <div style="display: flex; align-items: center; margin-bottom: 10px;">
                        <span style="font-size: 24px; margin-right: 10px;">⚠️</span>
                        <strong style="color: #856404;">Warning: Time Data Will Be Lost</strong>
                    </div>
                    <p style="color: #856404; font-size: 14px; line-height: 1.5;">
                        Archiving will permanently remove all time tracking data for this item. Only the title, description, and priority will be saved. This action cannot be undone.
                    </p>
                </div>
                <p style="font-size: 14px; color: #666;">Do you want to continue?</p>
            </div>
            <div class="btn-group">
                <button class="btn btn-danger" onclick="confirmArchiveWorkItem()">Yes, Archive</button>
                <button class="btn btn-secondary" onclick="closeArchiveConfirmation()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Settings Overlay -->
    <div class="overlay" id="settingsOverlay">
        <div class="floating-box">
            <h2>Settings</h2>
            <div style="margin: 20px 0;">
                <h3 style="font-size: 18px; margin-bottom: 15px; color: #333;">OneDrive Integration</h3>
                <div id="oneDriveStatus" style="margin-bottom: 15px; padding: 10px; background: #f0f0f0; border-radius: 5px; font-size: 14px;">
                    Not signed in
                </div>
                <button class="btn btn-primary" id="oneDriveSignInBtn" onclick="signInToOneDrive()">Sign In to OneDrive</button>
                <button class="btn btn-danger" id="oneDriveSignOutBtn" onclick="signOutFromOneDrive()" style="display: none;">Sign Out</button>

                <div id="autoBackupSection" style="display: none; margin-top: 20px; padding: 15px; background: #f9f9f9; border-radius: 5px;">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 14px;">
                        <input type="checkbox" id="autoBackupCheckbox" onchange="toggleAutoBackup()" style="margin-right: 10px; width: 18px; height: 18px; cursor: pointer;">
                        <span>Enable automatic backup every 1 hour</span>
                    </label>
                    <div id="lastBackupTime" style="margin-top: 10px; font-size: 12px; color: #666;"></div>
                </div>
            </div>
            <div class="btn-group">
                <button class="btn btn-secondary" onclick="closeSettingsDialog()">Close</button>
            </div>
        </div>
    </div>

    <script>
        let workItems = [];
        let draggedElement = null;
        let activeTimers = {}; // Store timers by work item ID
        let stickyNotes = [];
        let archivedItems = []; // Store archived items (title, description, priority only)
        let selectedNoteColor = '#FFD700';
        let draggedNote = null;
        let noteOffsetX = 0;
        let noteOffsetY = 0;
        let contextMenuNoteId = null;
        let contextMenuWorkItemId = null;
        let autoSaveInterval = null;
        let draggedCardId = null; // For drag-to-timer functionality
        let draggedFromColumn = null;

        // MSAL Configuration for OneDrive
        const msalConfig = {
            auth: {
                clientId: 'ba550467-95d1-4a39-98da-db155d745d85',
                authority: 'https://login.microsoftonline.com/common',
                redirectUri: window.location.href.split('?')[0].split('#')[0]
            },
            cache: {
                cacheLocation: 'localStorage',
                storeAuthStateInCookie: false
            },
            system: {
                allowRedirectInIframe: true
            }
        };

        const loginRequest = {
            scopes: ['User.Read', 'Files.ReadWrite', 'offline_access']
        };

        let msalInstance = null;
        let currentAccount = null;
        let oneDriveAccessToken = null;
        let autoBackupEnabled = false;
        let autoBackupInterval = null;
        const ONEDRIVE_FOLDER_NAME = 'WorkItemTimeManagement';
        const ONEDRIVE_BACKUP_FILE = 'remote-backup.json';

        // Initialize MSAL
        async function initializeMsal() {
            try {
                msalInstance = new msal.PublicClientApplication(msalConfig);
                await msalInstance.initialize();

                // Check if there's already a signed-in account
                const accounts = msalInstance.getAllAccounts();
                if (accounts.length > 0) {
                    currentAccount = accounts[0];
                    updateOneDriveStatus();
                }
            } catch (error) {
                console.error('MSAL initialization error:', error);
            }
        }

        // Sign in to OneDrive
        async function signInToOneDrive() {
            try {
                const response = await msalInstance.loginPopup(loginRequest);
                currentAccount = response.account;
                updateOneDriveStatus();
                console.log('Successfully signed in:', currentAccount.username);
            } catch (error) {
                console.error('OneDrive sign-in error:', error);
                if (error.errorCode !== 'user_cancelled') {
                    alert('Failed to sign in to OneDrive: ' + error.message);
                }
            }
        }

        // Sign out from OneDrive
        function signOutFromOneDrive() {
            if (currentAccount) {
                // Stop auto backup
                if (autoBackupInterval) {
                    clearInterval(autoBackupInterval);
                    autoBackupInterval = null;
                }
                autoBackupEnabled = false;

                msalInstance.logoutPopup({
                    account: currentAccount
                }).then(() => {
                    currentAccount = null;
                    oneDriveAccessToken = null;
                    updateOneDriveStatus();
                }).catch(error => {
                    console.error('OneDrive sign-out error:', error);
                });
            }
        }

        // Get OneDrive access token
        async function getOneDriveAccessToken() {
            if (!currentAccount) {
                throw new Error('Not signed in to OneDrive');
            }

            try {
                const response = await msalInstance.acquireTokenSilent({
                    scopes: loginRequest.scopes,
                    account: currentAccount
                });
                oneDriveAccessToken = response.accessToken;
                return oneDriveAccessToken;
            } catch (error) {
                console.error('Silent token acquisition failed, trying popup', error);
                const response = await msalInstance.acquireTokenPopup({
                    scopes: loginRequest.scopes,
                    account: currentAccount
                });
                oneDriveAccessToken = response.accessToken;
                return oneDriveAccessToken;
            }
        }

        // Ensure OneDrive folder exists
        async function ensureOneDriveFolder() {
            const token = await getOneDriveAccessToken();

            // Check if folder exists
            try {
                const response = await fetch(`https://graph.microsoft.com/v1.0/me/drive/root:/${ONEDRIVE_FOLDER_NAME}`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (response.ok) {
                    return await response.json();
                }
            } catch (error) {
                console.log('Folder does not exist, creating it');
            }

            // Create folder
            const response = await fetch('https://graph.microsoft.com/v1.0/me/drive/root/children', {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${token}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                    name: ONEDRIVE_FOLDER_NAME,
                    folder: {},
                    '@microsoft.graph.conflictBehavior': 'fail'
                })
            });

            if (!response.ok) {
                throw new Error('Failed to create OneDrive folder');
            }

            return await response.json();
        }

        // Export to OneDrive
        async function exportToOneDrive() {
            try {
                await ensureOneDriveFolder();

                const exportData = {
                    workItems: workItems,
                    stickyNotes: stickyNotes,
                    archivedItems: archivedItems,
                    activeTimers: serializeActiveTimers()
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const token = await getOneDriveAccessToken();

                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/root:/${ONEDRIVE_FOLDER_NAME}/${ONEDRIVE_BACKUP_FILE}:/content`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: dataStr
                    }
                );

                if (!response.ok) {
                    throw new Error('Failed to export to OneDrive');
                }

                // Update last backup time
                const now = new Date();
                localStorage.setItem('lastOneDriveBackup', now.toISOString());
                updateLastBackupTime();

                alert('Successfully exported to OneDrive!');
            } catch (error) {
                console.error('OneDrive export error:', error);
                alert('Failed to export to OneDrive: ' + error.message);
            }
        }

        // Import from OneDrive
        async function importFromOneDrive() {
            try {
                const token = await getOneDriveAccessToken();

                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/root:/${ONEDRIVE_FOLDER_NAME}/${ONEDRIVE_BACKUP_FILE}:/content`,
                    {
                        headers: {
                            'Authorization': `Bearer ${token}`
                        }
                    }
                );

                if (!response.ok) {
                    if (response.status === 404) {
                        alert('No backup file found on OneDrive. Please export first.');
                    } else {
                        throw new Error('Failed to import from OneDrive');
                    }
                    return;
                }

                const imported = await response.json();

                workItems = imported.workItems || [];
                workItems = workItems.map(item => migrateWorkItem(item));

                stickyNotes = imported.stickyNotes || [];
                archivedItems = imported.archivedItems || [];

                if (imported.activeTimers) {
                    deserializeActiveTimers(imported.activeTimers);
                }

                saveToLocalStorage();
                renderWorkItems();
                renderNotes();
                closeSaveLoadDialog();

                alert('Successfully imported from OneDrive!');
            } catch (error) {
                console.error('OneDrive import error:', error);
                alert('Failed to import from OneDrive: ' + error.message);
            }
        }

        // Auto backup to OneDrive
        async function autoBackupToOneDrive() {
            if (!currentAccount || !autoBackupEnabled) {
                return;
            }

            try {
                await ensureOneDriveFolder();

                const exportData = {
                    workItems: workItems,
                    stickyNotes: stickyNotes,
                    archivedItems: archivedItems,
                    activeTimers: serializeActiveTimers()
                };

                const dataStr = JSON.stringify(exportData, null, 2);
                const token = await getOneDriveAccessToken();

                const response = await fetch(
                    `https://graph.microsoft.com/v1.0/me/drive/root:/${ONEDRIVE_FOLDER_NAME}/${ONEDRIVE_BACKUP_FILE}:/content`,
                    {
                        method: 'PUT',
                        headers: {
                            'Authorization': `Bearer ${token}`,
                            'Content-Type': 'application/json'
                        },
                        body: dataStr
                    }
                );

                if (response.ok) {
                    const now = new Date();
                    localStorage.setItem('lastOneDriveBackup', now.toISOString());
                    updateLastBackupTime();
                    console.log('Auto backup to OneDrive successful');
                }
            } catch (error) {
                console.error('Auto backup failed:', error);
            }
        }

        // Toggle auto backup
        function toggleAutoBackup() {
            const checkbox = document.getElementById('autoBackupCheckbox');
            autoBackupEnabled = checkbox.checked;
            localStorage.setItem('autoBackupEnabled', autoBackupEnabled);

            if (autoBackupEnabled) {
                // Start auto backup interval (1 hour = 3600000 ms)
                if (autoBackupInterval) {
                    clearInterval(autoBackupInterval);
                }
                autoBackupInterval = setInterval(autoBackupToOneDrive, 3600000);

                // Do an immediate backup
                autoBackupToOneDrive();
            } else {
                // Stop auto backup
                if (autoBackupInterval) {
                    clearInterval(autoBackupInterval);
                    autoBackupInterval = null;
                }
            }
        }

        // Update last backup time display
        function updateLastBackupTime() {
            const lastBackup = localStorage.getItem('lastOneDriveBackup');
            const lastBackupDiv = document.getElementById('lastBackupTime');

            if (lastBackup) {
                const date = new Date(lastBackup);
                lastBackupDiv.textContent = `Last backup: ${date.toLocaleString()}`;
            } else {
                lastBackupDiv.textContent = 'No backups yet';
            }
        }

        // Update OneDrive status display
        function updateOneDriveStatus() {
            const statusDiv = document.getElementById('oneDriveStatus');
            const signInBtn = document.getElementById('oneDriveSignInBtn');
            const signOutBtn = document.getElementById('oneDriveSignOutBtn');
            const autoBackupSection = document.getElementById('autoBackupSection');
            const oneDriveButtons = document.getElementById('oneDriveButtons');

            if (currentAccount) {
                statusDiv.innerHTML = `Signed in as: <strong>${currentAccount.username}</strong>`;
                statusDiv.style.background = '#d4edda';
                statusDiv.style.color = '#155724';
                signInBtn.style.display = 'none';
                signOutBtn.style.display = 'inline-block';
                autoBackupSection.style.display = 'block';
                if (oneDriveButtons) oneDriveButtons.style.display = 'block';

                // Restore auto backup setting
                const savedAutoBackup = localStorage.getItem('autoBackupEnabled');
                if (savedAutoBackup === 'true') {
                    autoBackupEnabled = true;
                    document.getElementById('autoBackupCheckbox').checked = true;
                    // Restart interval
                    if (autoBackupInterval) {
                        clearInterval(autoBackupInterval);
                    }
                    autoBackupInterval = setInterval(autoBackupToOneDrive, 3600000);
                }

                updateLastBackupTime();
            } else {
                statusDiv.innerHTML = 'Not signed in';
                statusDiv.style.background = '#f0f0f0';
                statusDiv.style.color = '#333';
                signInBtn.style.display = 'inline-block';
                signOutBtn.style.display = 'none';
                autoBackupSection.style.display = 'none';
                if (oneDriveButtons) oneDriveButtons.style.display = 'none';
            }
        }

        // Settings dialog functions
        function showSettingsDialog() {
            updateOneDriveStatus();
            document.getElementById('settingsOverlay').classList.add('active');
        }

        function closeSettingsDialog() {
            document.getElementById('settingsOverlay').classList.remove('active');
        }

        // Load from localStorage on startup
        window.addEventListener('DOMContentLoaded', function() {
            initializeMsal();
            loadFromLocalStorage();
            renderWorkItems();
            renderNotes();
            // Start auto-save interval (every 60 seconds)
            startAutoSave();
        });

        // Auto-save timer state every 60 seconds
        function startAutoSave() {
            if (autoSaveInterval) {
                clearInterval(autoSaveInterval);
            }
            autoSaveInterval = setInterval(() => {
                if (Object.keys(activeTimers).length > 0) {
                    saveToLocalStorage();
                }
            }, 60000); // 60 seconds
        }

        // Show/Hide Dialogs
        function showAddItemDialog() {
            document.getElementById('addItemOverlay').classList.add('active');
        }

        function closeAddItemDialog() {
            document.getElementById('addItemOverlay').classList.remove('active');
        }

        function showSaveLoadDialog() {
            updateOneDriveStatus();
            document.getElementById('saveLoadOverlay').classList.add('active');
        }

        function closeSaveLoadDialog() {
            document.getElementById('saveLoadOverlay').classList.remove('active');
        }

        function clearAddItemForm() {
            document.getElementById('workItemTitle').value = '';
            document.getElementById('workItemDescription').value = '';
        }

        // Add Work Item
        function addWorkItem() {
            const title = document.getElementById('workItemTitle').value.trim();
            const description = document.getElementById('workItemDescription').value.trim();

            if (!title) {
                alert('Please enter a work item title');
                return;
            }

            const workItem = {
                id: Date.now(),
                title: title,
                description: description,
                priority: 'none', // All new items start in "No Priority"
                timeRecordings: [] // Array of {startTime, endTime, duration}
            };

            workItems.push(workItem);
            saveToLocalStorage();
            renderWorkItems();
            clearAddItemForm();
            closeAddItemDialog();
        }

        // Render Work Items in Kanban Board
        function renderWorkItems() {
            const container = document.getElementById('cardsContainer');
            container.innerHTML = '';

            // Create 4 columns
            const columns = {
                high: { title: 'High', items: [] },
                medium: { title: 'Medium', items: [] },
                low: { title: 'Low', items: [] },
                none: { title: 'No Priority', items: [] }
            };

            // Sort items into columns
            workItems.forEach(item => {
                const priority = item.priority || 'none';
                if (columns[priority]) {
                    columns[priority].items.push(item);
                }
            });

            // Render each column
            Object.keys(columns).forEach(priority => {
                const column = columns[priority];
                const columnDiv = document.createElement('div');
                columnDiv.className = 'kanban-column';
                columnDiv.dataset.priority = priority;

                // Column header
                const header = document.createElement('div');
                header.className = `kanban-column-header ${priority}`;
                header.textContent = column.title;
                columnDiv.appendChild(header);

                // Column cards container
                const cardsContainer = document.createElement('div');
                cardsContainer.className = 'kanban-column-cards';
                cardsContainer.dataset.priority = priority;

                // Add drop event listeners to column
                cardsContainer.addEventListener('dragover', handleColumnDragOver);
                cardsContainer.addEventListener('drop', handleColumnDrop);

                // Render cards in this column
                column.items.forEach(item => {
                    const card = createWorkCard(item);
                    cardsContainer.appendChild(card);
                });

                columnDiv.appendChild(cardsContainer);
                container.appendChild(columnDiv);
            });
        }

        // Create a work card element
        function createWorkCard(item) {
            const card = document.createElement('div');
            card.className = `work-card ${item.priority}`;
            card.draggable = true;
            card.dataset.itemId = item.id;

            // Calculate total time logged
            const totalSeconds = item.timeRecordings.reduce((sum, rec) => sum + (rec.duration || 0), 0);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const timeText = totalSeconds > 0 ? `${hours}h ${minutes}m` : 'No time logged';

            card.innerHTML = `
                <div class="card-content">
                    <div class="card-title">${item.title}</div>
                    <div class="card-time">${timeText}</div>
                </div>
            `;

            // Click to show details
            card.addEventListener('click', () => showWorkItemDetail(item.id));

            // Drag events
            card.addEventListener('dragstart', handleCardDragStart);
            card.addEventListener('dragend', handleCardDragEnd);
            card.addEventListener('contextmenu', (e) => showWorkItemContextMenu(e, item.id));

            return card;
        }

        // Work Item Detail Dialog
        function showWorkItemDetail(itemId) {
            const item = workItems.find(i => i.id === itemId);
            if (!item) return;

            document.getElementById('detailTitleText').textContent = item.title;
            document.getElementById('detailDescription').textContent = item.description || 'No description';

            // Calculate total time logged
            const totalSeconds = item.timeRecordings.reduce((sum, rec) => sum + (rec.duration || 0), 0);
            const hours = Math.floor(totalSeconds / 3600);
            const minutes = Math.floor((totalSeconds % 3600) / 60);
            const seconds = totalSeconds % 60;
            const timeText = `${hours}h ${minutes}m ${seconds}s`;

            document.getElementById('detailTimeLogged').textContent = timeText;

            // Calculate and display last 7 days of time tracking
            const last7Days = getLast7DaysTimeBreakdown(item.timeRecordings);
            const dailyBreakdownEl = document.getElementById('detailDailyBreakdown');
            dailyBreakdownEl.innerHTML = last7Days.map(day => {
                const dayHours = Math.floor(day.seconds / 3600);
                const dayMinutes = Math.floor((day.seconds % 3600) / 60);
                const timeDisplay = day.seconds > 0 ? `${dayHours}h ${dayMinutes}m` : '0h 0m';
                return `<div style="display: flex; justify-content: space-between; padding: 5px 0; border-bottom: 1px solid #eee;">
                    <span>${day.date}</span>
                    <span style="font-weight: bold;">${timeDisplay}</span>
                </div>`;
            }).join('');

            document.getElementById('workItemDetailOverlay').classList.add('active');
        }

        // Get time breakdown for last 7 days
        function getLast7DaysTimeBreakdown(timeRecordings) {
            const today = new Date();
            const last7Days = [];

            // Generate array of last 7 days (including today)
            for (let i = 6; i >= 0; i--) {
                const date = new Date(today);
                date.setDate(date.getDate() - i);
                const dateString = date.toISOString().split('T')[0];
                last7Days.push({
                    date: dateString,
                    seconds: 0
                });
            }

            // Aggregate time recordings by date
            timeRecordings.forEach(rec => {
                const recDate = rec.date || new Date(rec.startTime).toISOString().split('T')[0];
                const dayEntry = last7Days.find(d => d.date === recDate);
                if (dayEntry) {
                    dayEntry.seconds += rec.duration || 0;
                }
            });

            return last7Days;
        }

        function closeWorkItemDetail() {
            document.getElementById('workItemDetailOverlay').classList.remove('active');
        }

        // Kanban Drag and Drop Functions
        function handleCardDragStart(e) {
            draggedCardId = parseInt(this.dataset.itemId);
            this.classList.add('dragging');
            e.dataTransfer.effectAllowed = 'move';

            // Find which column this card is in
            const item = workItems.find(i => i.id === draggedCardId);
            if (item) {
                draggedFromColumn = item.priority;
            }
        }

        function handleCardDragEnd(e) {
            this.classList.remove('dragging');
            draggedCardId = null;
            draggedFromColumn = null;
        }

        function handleColumnDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
        }

        function handleColumnDrop(e) {
            e.preventDefault();
            e.stopPropagation();

            const targetPriority = this.dataset.priority;

            if (draggedCardId !== null) {
                // Moving card between columns - update priority
                const item = workItems.find(i => i.id === draggedCardId);
                if (item && item.priority !== targetPriority) {
                    item.priority = targetPriority;
                    saveToLocalStorage();
                    renderWorkItems();
                }
            }
        }

        // Timer Sidebar - Drag to start timer
        const timerSidebar = document.getElementById('timerSidebar');
        timerSidebar.addEventListener('dragover', function(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'copy';
            timerSidebar.style.background = 'rgb(140, 140, 140)'; // Visual feedback
        });

        timerSidebar.addEventListener('dragleave', function(e) {
            timerSidebar.style.background = 'rgb(160, 160, 160)';
        });

        timerSidebar.addEventListener('drop', function(e) {
            e.preventDefault();
            timerSidebar.style.background = 'rgb(160, 160, 160)';

            if (draggedCardId !== null) {
                const item = workItems.find(i => i.id === draggedCardId);
                if (item && !activeTimers[item.id]) {
                    startTimer(item.id);
                }
            }
        });

        // Timer Functions - Count Up
        function startTimer(itemId) {
            const item = workItems.find(i => i.id === itemId);
            if (!item) return;

            // Create new timer (count-up)
            const timer = {
                itemId: item.id,
                startTime: Date.now(),
                elapsedSeconds: 0,
                paused: false,
                interval: null
            };

            activeTimers[item.id] = timer;

            // Start the timer interval
            timer.interval = setInterval(() => updateTimer(item.id), 1000);

            renderActiveTimers();
            saveToLocalStorage();
        }

        function updateTimer(itemId) {
            const timer = activeTimers[itemId];
            if (!timer || timer.paused) return;

            timer.elapsedSeconds++;
            renderActiveTimers();

            // Check for 8-hour warning (28800 seconds)
            if (timer.elapsedSeconds === 28800) {
                const item = workItems.find(i => i.id == itemId);
                playTimerWarning();
                if (confirm(`Timer Alert!\n\nThe timer for "${item ? item.title : 'Work Item'}" has been running for 8 hours.\n\nHave you forgotten about this timer?\n\nClick OK to stop the timer, or Cancel to continue.`)) {
                    stopTimer(itemId);
                }
            }

            // Auto-save timer progress every 60 seconds
            if (timer.elapsedSeconds % 60 === 0) {
                saveToLocalStorage();
            }
        }

        // Play timer warning sound
        function playTimerWarning() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                // Play 3 beeps
                for (let i = 0; i < 3; i++) {
                    setTimeout(() => {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();

                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);

                        oscillator.frequency.value = 880;
                        oscillator.type = 'sine';

                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.5);

                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.5);
                    }, i * 600);
                }
            } catch (error) {
                console.error('Audio playback failed:', error);
            }
        }

        function pauseTimer(itemId) {
            const timer = activeTimers[itemId];
            if (timer) {
                timer.paused = true;
                clearInterval(timer.interval);
                timer.interval = null;
                renderActiveTimers();
                saveToLocalStorage();
            }
        }

        function resumeTimer(itemId) {
            const timer = activeTimers[itemId];
            if (timer) {
                timer.paused = false;
                timer.startTime = Date.now() - (timer.elapsedSeconds * 1000);
                timer.interval = setInterval(() => updateTimer(itemId), 1000);
                renderActiveTimers();
                saveToLocalStorage();
            }
        }

        function stopTimer(itemId) {
            const timer = activeTimers[itemId];
            if (!timer) return;

            // Save time recording to work item with date
            const item = workItems.find(i => i.id === itemId);
            if (item) {
                const now = new Date();
                const dateString = now.toISOString().split('T')[0]; // YYYY-MM-DD format
                const recording = {
                    startTime: timer.startTime,
                    endTime: Date.now(),
                    duration: timer.elapsedSeconds,
                    date: dateString
                };
                item.timeRecordings.push(recording);
            }

            // Clear the timer
            if (timer.interval) {
                clearInterval(timer.interval);
            }
            delete activeTimers[itemId];

            saveToLocalStorage();
            renderWorkItems();
            renderActiveTimers();
        }

        // Render Active Timers in Sidebar
        function renderActiveTimers() {
            const container = document.getElementById('activeTimersContainer');
            container.innerHTML = '';

            Object.keys(activeTimers).forEach(itemId => {
                const timer = activeTimers[itemId];
                const item = workItems.find(i => i.id == itemId);

                if (!item) {
                    delete activeTimers[itemId];
                    return;
                }

                const hours = Math.floor(timer.elapsedSeconds / 3600);
                const minutes = Math.floor((timer.elapsedSeconds % 3600) / 60);
                const seconds = timer.elapsedSeconds % 60;
                const timeString = `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;

                // Add live indicator if timer is running
                const liveIndicator = !timer.paused ? '<span class="live-indicator"></span>' : '';

                const timerCard = document.createElement('div');
                timerCard.className = 'active-timer-card';
                timerCard.innerHTML = `
                    <h4>${item.title}${liveIndicator}</h4>
                    <div class="timer-clock-small">${timeString}</div>
                    <div class="timer-controls">
                        ${timer.paused ?
                            `<button class="timer-btn play" onclick="resumeTimer(${itemId})">Resume</button>` :
                            `<button class="timer-btn pause" onclick="pauseTimer(${itemId})">Pause</button>`
                        }
                        <button class="timer-btn cancel" onclick="stopTimer(${itemId})">Stop</button>
                    </div>
                `;
                container.appendChild(timerCard);
            });
        }


        // Notes Functions
        function showAddNoteDialog() {
            document.getElementById('addNoteOverlay').classList.add('active');
        }

        function closeAddNoteDialog() {
            document.getElementById('addNoteOverlay').classList.remove('active');
        }

        function selectNoteColor(color, event) {
            selectedNoteColor = color;
            document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
            event.target.classList.add('selected');
        }

        function clearAddNoteForm() {
            document.getElementById('noteTitle').value = '';
            document.getElementById('noteText').value = '';
            selectedNoteColor = '#FFD700';
            document.querySelectorAll('.color-option').forEach(opt => opt.classList.remove('selected'));
            document.querySelectorAll('.color-option')[0].classList.add('selected');
        }

        function addNote() {
            const title = document.getElementById('noteTitle').value.trim();
            const text = document.getElementById('noteText').value.trim();

            if (!title) {
                alert('Please enter a note title');
                return;
            }

            if (!text) {
                alert('Please enter note text');
                return;
            }

            const note = {
                id: Date.now(),
                title: title,
                text: text,
                color: selectedNoteColor,
                x: 50,
                y: 50,
                collapsed: false,
                width: 200,
                height: 150
            };

            stickyNotes.push(note);
            saveToLocalStorage();
            renderNotes();
            clearAddNoteForm();
            closeAddNoteDialog();
        }

        function deleteNote(noteId) {
            stickyNotes = stickyNotes.filter(note => note.id !== noteId);
            saveToLocalStorage();
            renderNotes();
        }

        function renderNotes() {
            const container = document.getElementById('notesSection');

            // Remove existing notes
            const existingNotes = container.querySelectorAll('.sticky-note');
            existingNotes.forEach(note => note.remove());

            stickyNotes.forEach(note => {
                const noteEl = document.createElement('div');
                noteEl.className = `sticky-note ${note.collapsed ? 'collapsed' : ''}`;
                noteEl.style.backgroundColor = note.color;
                noteEl.style.left = note.x + 'px';
                noteEl.style.top = note.y + 'px';
                noteEl.style.width = (note.width || 200) + 'px';
                noteEl.style.height = (note.height || 150) + 'px';
                noteEl.dataset.noteId = note.id;

                const collapseIcon = note.collapsed ? '▼' : '−';

                // When collapsed, show only title in header. When expanded, show title in content
                if (note.collapsed) {
                    noteEl.innerHTML = `
                        <div class="note-header">
                            <div class="note-title-header">${note.title || 'Untitled'}</div>
                            <button class="note-btn" onclick="toggleNoteCollapse(${note.id})" title="Expand">${collapseIcon}</button>
                        </div>
                        <div class="note-content" style="display: none;"></div>
                    `;
                } else {
                    noteEl.innerHTML = `
                        <div class="note-header">
                            <button class="note-btn" onclick="toggleNoteCollapse(${note.id})" title="Collapse">${collapseIcon}</button>
                        </div>
                        <div class="note-content"><strong>${note.title || 'Untitled'}</strong><br>${note.text}</div>
                    `;
                }

                noteEl.addEventListener('mousedown', startNoteDrag);
                noteEl.addEventListener('dblclick', () => editNote(note.id));
                noteEl.addEventListener('contextmenu', (e) => showNoteContextMenu(e, note.id));

                // Add resize observer to save dimensions
                const resizeObserver = new ResizeObserver(entries => {
                    for (let entry of entries) {
                        const noteId = parseInt(entry.target.dataset.noteId);
                        const note = stickyNotes.find(n => n.id === noteId);
                        if (note && !note.collapsed) {
                            note.width = entry.contentRect.width;
                            note.height = entry.contentRect.height;
                            saveToLocalStorage();
                        }
                    }
                });
                resizeObserver.observe(noteEl);

                container.appendChild(noteEl);
            });
        }

        function toggleNoteCollapse(noteId) {
            const note = stickyNotes.find(n => n.id === noteId);
            if (note) {
                note.collapsed = !note.collapsed;
                saveToLocalStorage();
                renderNotes();
            }
        }

        function showNoteContextMenu(e, noteId) {
            e.preventDefault();
            contextMenuNoteId = noteId;
            const contextMenu = document.getElementById('noteContextMenu');
            contextMenu.style.left = e.clientX + 'px';
            contextMenu.style.top = e.clientY + 'px';
            contextMenu.classList.add('active');
        }

        function closeContextMenu() {
            document.getElementById('noteContextMenu').classList.remove('active');
            contextMenuNoteId = null;
        }

        function deleteNoteFromContext() {
            if (contextMenuNoteId !== null) {
                deleteNote(contextMenuNoteId);
                closeContextMenu();
            }
        }

        function startNoteDrag(e) {
            if (e.target.classList.contains('note-btn')) return;

            draggedNote = this;
            const rect = draggedNote.getBoundingClientRect();
            const parentRect = document.getElementById('notesSection').getBoundingClientRect();

            // Check if click is in the resize handle area (bottom-right 15px corner)
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            const isInResizeArea = (clickX > rect.width - 15) && (clickY > rect.height - 15);

            // Don't start drag if in resize area
            if (isInResizeArea) {
                draggedNote = null;
                return;
            }

            noteOffsetX = e.clientX - rect.left;
            noteOffsetY = e.clientY - rect.top;

            draggedNote.classList.add('dragging');

            document.addEventListener('mousemove', dragNote);
            document.addEventListener('mouseup', endNoteDrag);
        }

        function dragNote(e) {
            if (!draggedNote) return;

            const parentRect = document.getElementById('notesSection').getBoundingClientRect();
            let newX = e.clientX - parentRect.left - noteOffsetX;
            let newY = e.clientY - parentRect.top - noteOffsetY;

            // Keep within bounds
            newX = Math.max(0, Math.min(newX, parentRect.width - draggedNote.offsetWidth));
            newY = Math.max(0, Math.min(newY, parentRect.height - draggedNote.offsetHeight));

            draggedNote.style.left = newX + 'px';
            draggedNote.style.top = newY + 'px';
        }

        function endNoteDrag(e) {
            if (!draggedNote) return;

            draggedNote.classList.remove('dragging');

            // Update note position in data
            const noteId = parseInt(draggedNote.dataset.noteId);
            const note = stickyNotes.find(n => n.id === noteId);
            if (note) {
                note.x = parseInt(draggedNote.style.left);
                note.y = parseInt(draggedNote.style.top);
                saveToLocalStorage();
            }

            document.removeEventListener('mousemove', dragNote);
            document.removeEventListener('mouseup', endNoteDrag);
            draggedNote = null;
        }

        // Save/Load Functions
        function saveToJSON() {
            const exportData = {
                workItems: workItems,
                stickyNotes: stickyNotes,
                archivedItems: archivedItems,
                activeTimers: serializeActiveTimers()
            };
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'time-management-' + new Date().toISOString().split('T')[0] + '.json';
            link.click();
            URL.revokeObjectURL(url);
            closeSaveLoadDialog();
        }

        function importJSON(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const imported = JSON.parse(e.target.result);
                    // Handle old format (just array) or new format (object)
                    if (Array.isArray(imported)) {
                        workItems = migrateOldWorkItems(imported);
                    } else {
                        workItems = imported.workItems || [];
                        // Migrate old format work items to new format
                        workItems = workItems.map(item => migrateWorkItem(item));

                        stickyNotes = imported.stickyNotes || [];
                        archivedItems = imported.archivedItems || [];
                        // Restore active timers if present
                        if (imported.activeTimers) {
                            deserializeActiveTimers(imported.activeTimers);
                        }
                    }
                    saveToLocalStorage();
                    renderWorkItems();
                    renderNotes();
                    closeSaveLoadDialog();
                    alert('Data imported successfully!');
                } catch (error) {
                    alert('Error importing file: ' + error.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // Migrate old work item format to new format
        function migrateWorkItem(item) {
            // If already in new format with timeRecordings
            if (item.timeRecordings) {
                // Ensure all recordings have a date field
                item.timeRecordings = item.timeRecordings.map(rec => {
                    if (!rec.date && rec.startTime) {
                        // Add date based on startTime
                        rec.date = new Date(rec.startTime).toISOString().split('T')[0];
                    }
                    return rec;
                });
                return item;
            }

            // Migrate from old format
            return {
                id: item.id,
                title: item.title,
                description: '', // Old format didn't have description
                priority: item.priority || 'none',
                timeRecordings: [] // Old format tracked totalMinutes, not recordings
            };
        }

        function migrateOldWorkItems(items) {
            return items.map(item => migrateWorkItem(item));
        }

        function clearWork() {
            closeSaveLoadDialog();
            document.getElementById('clearConfirmationOverlay').classList.add('active');
        }

        function confirmClearWork() {
            // Cancel all active timers
            Object.keys(activeTimers).forEach(itemId => {
                const timer = activeTimers[itemId];
                if (timer.interval) {
                    clearInterval(timer.interval);
                }
            });
            activeTimers = {};

            workItems = [];
            stickyNotes = [];
            archivedItems = [];
            saveToLocalStorage();
            renderWorkItems();
            renderNotes();
            renderActiveTimers();
            closeClearConfirmationDialog();
        }

        function closeClearConfirmationDialog() {
            document.getElementById('clearConfirmationOverlay').classList.remove('active');
        }

        // LocalStorage Functions
        function saveToLocalStorage() {
            const data = {
                workItems: workItems,
                stickyNotes: stickyNotes,
                archivedItems: archivedItems,
                activeTimers: serializeActiveTimers()
            };
            localStorage.setItem('timeManagementData', JSON.stringify(data));
        }

        function serializeActiveTimers() {
            const serializedTimers = {};
            Object.keys(activeTimers).forEach(itemId => {
                const timer = activeTimers[itemId];
                serializedTimers[itemId] = {
                    itemId: timer.itemId,
                    startTime: timer.startTime,
                    elapsedSeconds: timer.elapsedSeconds,
                    paused: timer.paused,
                    timestamp: Date.now()
                };
            });
            return serializedTimers;
        }

        function deserializeActiveTimers(savedTimers) {
            if (!savedTimers) return;

            Object.keys(savedTimers).forEach(itemId => {
                const saved = savedTimers[itemId];
                const item = workItems.find(item => item.id == itemId);

                if (item) {
                    const timer = {
                        itemId: saved.itemId,
                        startTime: saved.startTime,
                        elapsedSeconds: saved.elapsedSeconds || 0,
                        paused: saved.paused,
                        interval: null
                    };

                    activeTimers[itemId] = timer;

                    // Resume timer if it wasn't paused
                    if (!timer.paused) {
                        timer.interval = setInterval(() => updateTimer(itemId), 1000);
                    }
                }
            });

            if (Object.keys(activeTimers).length > 0) {
                renderActiveTimers();
            }
        }

        function loadFromLocalStorage() {
            const saved = localStorage.getItem('timeManagementData');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    // Handle old format (just array) or new format (object)
                    if (Array.isArray(data)) {
                        workItems = migrateOldWorkItems(data);
                        stickyNotes = [];
                        archivedItems = [];
                    } else {
                        workItems = data.workItems || [];
                        // Migrate old format work items to new format
                        workItems = workItems.map(item => migrateWorkItem(item));

                        stickyNotes = data.stickyNotes || [];
                        // Ensure all notes have collapsed and title properties
                        stickyNotes = stickyNotes.map(note => ({
                            ...note,
                            collapsed: note.collapsed !== undefined ? note.collapsed : false,
                            title: note.title || 'Untitled'
                        }));

                        archivedItems = data.archivedItems || [];

                        // Restore active timers
                        deserializeActiveTimers(data.activeTimers);
                    }
                } catch (error) {
                    console.error('Error loading data:', error);
                    workItems = [];
                    stickyNotes = [];
                    archivedItems = [];
                }
            }
        }

        // Close overlays when clicking outside
        document.querySelectorAll('.overlay').forEach(overlay => {
            overlay.addEventListener('click', function(e) {
                if (e.target === this && this.id !== 'completionOverlay') {
                    this.classList.remove('active');
                }
            });
        });

        // Work Item Context Menu Functions
        function showWorkItemContextMenu(e, itemId) {
            e.preventDefault();
            contextMenuWorkItemId = itemId;
            const contextMenu = document.getElementById('workItemContextMenu');
            contextMenu.style.left = e.clientX + 'px';
            contextMenu.style.top = e.clientY + 'px';
            contextMenu.classList.add('active');
        }

        function closeWorkItemContextMenu() {
            document.getElementById('workItemContextMenu').classList.remove('active');
            contextMenuWorkItemId = null;
        }

        function deleteWorkItemFromContext() {
            if (contextMenuWorkItemId !== null) {
                // Stop any active timer for this item
                if (activeTimers[contextMenuWorkItemId]) {
                    const timer = activeTimers[contextMenuWorkItemId];
                    if (timer.interval) {
                        clearInterval(timer.interval);
                    }
                    delete activeTimers[contextMenuWorkItemId];
                }

                // Remove the work item
                workItems = workItems.filter(item => item.id !== contextMenuWorkItemId);
                saveToLocalStorage();
                renderWorkItems();
                renderActiveTimers();
                closeWorkItemContextMenu();
            }
        }

        function archiveWorkItemFromContext() {
            if (contextMenuWorkItemId !== null) {
                const item = workItems.find(i => i.id === contextMenuWorkItemId);
                if (item) {
                    // Show confirmation dialog with item title
                    document.getElementById('archiveConfirmItemTitle').textContent = item.title;
                    document.getElementById('archiveConfirmationOverlay').classList.add('active');
                    closeWorkItemContextMenu();
                }
            }
        }

        function closeArchiveConfirmation() {
            document.getElementById('archiveConfirmationOverlay').classList.remove('active');
            contextMenuWorkItemId = null;
        }

        function confirmArchiveWorkItem() {
            if (contextMenuWorkItemId !== null) {
                const item = workItems.find(i => i.id === contextMenuWorkItemId);
                if (item) {
                    // Stop any active timer for this item
                    if (activeTimers[contextMenuWorkItemId]) {
                        const timer = activeTimers[contextMenuWorkItemId];
                        if (timer.interval) {
                            clearInterval(timer.interval);
                        }
                        delete activeTimers[contextMenuWorkItemId];
                    }

                    // Create archived item with only title, description, and priority
                    const archivedItem = {
                        id: Date.now(), // New ID for archived item
                        title: item.title,
                        description: item.description || '',
                        priority: item.priority,
                        archivedDate: new Date().toISOString()
                    };

                    archivedItems.push(archivedItem);

                    // Remove from active work items
                    workItems = workItems.filter(i => i.id !== contextMenuWorkItemId);

                    saveToLocalStorage();
                    renderWorkItems();
                    renderActiveTimers();
                    closeArchiveConfirmation();
                }
            }
        }

        // Archive View Functions
        function showArchiveView() {
            renderArchiveList();
            closeSaveLoadDialog();
            document.getElementById('archiveViewOverlay').classList.add('active');
        }

        function closeArchiveView() {
            document.getElementById('archiveViewOverlay').classList.remove('active');
        }

        function renderArchiveList() {
            const container = document.getElementById('archiveList');

            if (archivedItems.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #888; padding: 40px 20px;">No archived items</p>';
                return;
            }

            container.innerHTML = archivedItems.map(item => {
                const archivedDate = new Date(item.archivedDate).toLocaleDateString();
                const priorityColors = {
                    high: '#FFB3BA',
                    medium: '#FFE4A3',
                    low: '#B4E7B4',
                    none: '#AED6F1'
                };
                const bgColor = priorityColors[item.priority] || priorityColors.none;

                return `
                    <div style="background: ${bgColor}; border-radius: 8px; padding: 15px; margin-bottom: 10px; display: flex; justify-content: space-between; align-items: start;">
                        <div style="flex: 1;">
                            <div style="font-weight: bold; font-size: 16px; margin-bottom: 5px;">${item.title}</div>
                            <div style="font-size: 14px; color: #555; margin-bottom: 5px;">${item.description || 'No description'}</div>
                            <div style="font-size: 12px; color: #666;">Priority: ${item.priority.charAt(0).toUpperCase() + item.priority.slice(1)} • Archived: ${archivedDate}</div>
                        </div>
                        <div style="display: flex; gap: 5px; margin-left: 10px;">
                            <button class="btn btn-info" style="padding: 8px 12px; font-size: 12px;" onclick="restoreArchivedItem(${item.id})">Restore</button>
                            <button class="btn btn-danger" style="padding: 8px 12px; font-size: 12px;" onclick="deleteArchivedItem(${item.id})">Delete</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function restoreArchivedItem(archivedItemId) {
            const archivedItem = archivedItems.find(i => i.id === archivedItemId);
            if (archivedItem) {
                // Create new work item from archived item
                const restoredItem = {
                    id: Date.now(), // New ID for restored item
                    title: archivedItem.title,
                    description: archivedItem.description,
                    priority: archivedItem.priority,
                    timeRecordings: [] // Start fresh with no time recordings
                };

                workItems.push(restoredItem);

                // Remove from archive
                archivedItems = archivedItems.filter(i => i.id !== archivedItemId);

                saveToLocalStorage();
                renderWorkItems();
                renderArchiveList();
            }
        }

        function deleteArchivedItem(archivedItemId) {
            if (confirm('Are you sure you want to permanently delete this archived item?')) {
                archivedItems = archivedItems.filter(i => i.id !== archivedItemId);
                saveToLocalStorage();
                renderArchiveList();
            }
        }

        // Close context menus when clicking anywhere
        document.addEventListener('click', function(e) {
            const noteContextMenu = document.getElementById('noteContextMenu');
            const workItemContextMenu = document.getElementById('workItemContextMenu');

            if (!noteContextMenu.contains(e.target) && noteContextMenu.classList.contains('active')) {
                closeContextMenu();
            }

            if (!workItemContextMenu.contains(e.target) && workItemContextMenu.classList.contains('active')) {
                closeWorkItemContextMenu();
            }
        });
    </script>
</body>
</html>
